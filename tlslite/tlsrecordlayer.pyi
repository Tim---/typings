from .utils.compat import *
from .utils.cryptomath import *
from .errors import *
from .messages import *
from .mathtls import *
from .constants import *
from .bufferedsocket import BufferedSocket as BufferedSocket
from .defragmenter import Defragmenter as Defragmenter
from .handshakehashes import HandshakeHashes as HandshakeHashes
from .handshakesettings import HandshakeSettings as HandshakeSettings
from .keyexchange import KeyExchange as KeyExchange
from .recordlayer import RecordLayer as RecordLayer
from .utils.codec import Parser as Parser
from .utils.compression import (
    choose_compression_send_algo as choose_compression_send_algo,
    compression_algo_impls as compression_algo_impls,
)
from .utils.lists import (
    getFirstMatching as getFirstMatching,
    to_str_delimiter as to_str_delimiter,
)
from _typeshed import Incomplete
from collections.abc import Generator

class TLSRecordLayer:
    sock: Incomplete
    session: Incomplete
    closed: bool
    resumed: bool
    allegedSrpUsername: Incomplete
    closeSocket: bool
    ignoreAbruptClose: bool
    fault: Incomplete
    tickets: Incomplete
    tls_1_0_tickets: Incomplete
    heartbeat_can_receive: bool
    heartbeat_can_send: bool
    heartbeat_supported: bool
    heartbeat_response_callback: Incomplete
    client_cert_required: bool
    def __init__(self, sock) -> None: ...
    @property
    def recordSize(self): ...
    @recordSize.setter
    def recordSize(self, value) -> None: ...
    @property
    def version(self): ...
    @version.setter
    def version(self, value) -> None: ...
    @property
    def encryptThenMAC(self): ...
    def clearReadBuffer(self) -> None: ...
    def clearWriteBuffer(self) -> None: ...
    def read(self, max: Incomplete | None = None, min: int = 1): ...
    client_cert_compression_algo: Incomplete
    def readAsync(
        self, max: Incomplete | None = None, min: int = 1
    ) -> Generator[Incomplete]: ...
    def unread(self, b) -> None: ...
    def write(self, s) -> None: ...
    def writeAsync(self, s) -> Generator[Incomplete]: ...
    def close(self) -> None: ...
    def closeAsync(self) -> Generator[Incomplete]: ...
    def getVersionName(self): ...
    def getCipherName(self): ...
    def getCipherImplementation(self): ...
    def send(self, s): ...
    def sendall(self, s) -> None: ...
    def recv(self, bufsize): ...
    def recv_into(self, b): ...
    def makefile(self, mode: str = "r", bufsize: int = -1): ...
    def getsockname(self): ...
    def getpeername(self): ...
    def settimeout(self, value): ...
    def gettimeout(self): ...
    def setsockopt(self, level, optname, value): ...
    def shutdown(self, how): ...
    def fileno(self) -> None: ...
    def write_heartbeat(self, payload, padding_length) -> Generator[Incomplete]: ...
    def send_heartbeat_request(self, payload, padding_length) -> None: ...
    def send_keyupdate_request(self, message_type) -> Generator[Incomplete]: ...
